-- Copyright 2020 The Cross-Media Measurement Authors
--
-- Licensed under the Apache License, Version 2.0 (the "License");
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--      http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.

-- Cloud Spanner database schema for the Kingdom.
--
-- Table hierarchy:
--   Root
--   ├── Advertisers
--   │   └── ReportConfigs
--   │       ├── ReportConfigCampaigns
--   │       └── ReportConfigSchedules
--   │           └── Reports
--   │               └── ReportLogEntries
--   │               └── ReportRequisitions
--   └── DataProviders
--       └── Campaigns
--           └── Requisitions
--
-- The important foreign key relationships between the tables are:
--
--   Advertisers <- 1:many -> Campaigns
--   ReportConfigs <- many:many -> Campaigns
--   Requisitions <- many:many -> Reports (tracked in ReportRequisitions)
--
-- Identifiers are random INT64s. APIs (and therefore by extension, UIs) should
-- expose only External identifiers, and ideally only web-safe base64 versions
-- of them without padding (e.g. RFC4648's base64url encoding without padding).
--
-- The schema contains many serialized protocol buffers, usually in two formats:
-- JSON and binary. This may be a little surprising that the data is duplicated.
-- In the long run, we intend to deduplicate this. However, in the short term,
-- JSON provides debugging value.
--
-- A ReportConfig specifies what statistics to generate reports for. The
-- ReportConfigSchedules for a ReportConfig determine the frequency with which
-- to generate these reports, and how many days' data to include in each. The
-- campaigns included in a ReportConfig are stored in ReportConfigCampaigns.
--
-- When it's time to act on a ReportConfigSchedule item, a Report is generated
-- in a pending state. Then, rows are added to Requisitions as necessary. Note
-- that Requisitions are not tied to a Report or ReportConfig -- multiple
-- Reports and ReportConfigs can utilize any Requisition.
--
-- Data Providers fetch the unfulfilled Requisitions for campaigns in their
-- systems, compute the underlying data, and upload it via the Publisher Data
-- Service.
--
-- Once all Requisitions for a Report have been fulfilled, the multi-party
-- computation can begin.

CREATE TABLE Advertisers (
  AdvertiserId          INT64 NOT NULL,

  ExternalAdvertiserId  INT64 NOT NULL,

  AdvertiserDetails     BYTES(MAX) NOT NULL,
  AdvertiserDetailsJson STRING(MAX) NOT NULL,
) PRIMARY KEY (AdvertiserId);

-- For advertiser APIs.
CREATE UNIQUE INDEX AdvertisersByExternalId ON Advertisers(ExternalAdvertiserId);


CREATE TABLE DataProviders (
  DataProviderId          INT64 NOT NULL,
  ExternalDataProviderId  INT64 NOT NULL,

  DataProviderDetails     BYTES(MAX) NOT NULL,
  DataProviderDetailsJson STRING(MAX) NOT NULL,
) PRIMARY KEY (DataProviderId);

-- For data provider APIs.
CREATE UNIQUE INDEX DataProvidersByExternalId ON DataProviders(ExternalDataProviderId);

-- Each Campaign belongs to both an Advertiser and a Data Provider.
--
-- This table is used as follows:
--   * Data Providers inform the Local Measurement Provider of all of their
--     campaigns and which Advertisers they belong to. The identifier provided
--     by the Data Provider for the campaign is stored as ProvidedCampaignId.
--   * The system generates the CampaignId and ExternalCampaignId.
--   * Advertisers, when setting up ReportConfigs, select a subset of the
--     Campaigns that belong to them.
--   * Each Requisition is a calculation for a specific campaign over a time
--     window.
--
-- This is interleaved under Data Providers to make bulk operations from Data
-- Provider APIs more efficient.
-- TODO: evaluate if interleaving under Advertiser would be more efficient.
CREATE TABLE Campaigns (
  DataProviderId          INT64 NOT NULL,
  CampaignId              INT64 NOT NULL,

  AdvertiserId            INT64 NOT NULL,

  -- Generated by the system, exposed in UIs.
  ExternalCampaignId      INT64 NOT NULL,

  -- Provided by the Data Provider.
  ProvidedCampaignId  STRING(MAX) NOT NULL,

  CampaignDetails         BYTES(MAX) NOT NULL,
  CampaignDetailsJson     STRING(MAX) NOT NULL,

  CONSTRAINT FK_Advertiser
    FOREIGN KEY (AdvertiserId)
    REFERENCES Advertisers(AdvertiserId),
) PRIMARY KEY (DataProviderId, CampaignId),
  INTERLEAVE IN PARENT DataProviders ON DELETE CASCADE;

-- Used for Advertiser APIs, e.g. to support UIs showing all campaigns that an
-- advertiser owns.
CREATE INDEX CampaignsByAdvertiser ON Campaigns(AdvertiserId);
CREATE UNIQUE INDEX CampaignsByExternalId ON Campaigns(ExternalCampaignId);
CREATE INDEX CampaignsByProvidedId ON Campaigns(ProvidedCampaignId);


CREATE TABLE ReportConfigs (
  AdvertiserId            INT64 NOT NULL,

  ReportConfigId          INT64 NOT NULL,
  ExternalReportConfigId  INT64 NOT NULL,

  -- Denormalization of the number of requisitions required for reports from
  -- this report config. In effect, it's the product of the number of
  -- interleaved campaigns and the number of MetricDefinitions embedded in
  -- ReportConfigDetails.
  NumRequisitions         INT64 NOT NULL,

  -- ReportConfigState proto enum.
  State                   INT64 NOT NULL,

  -- ReportConfigDetails serialized proto.
  ReportConfigDetails     BYTES(MAX) NOT NULL,
  ReportConfigDetailsJson STRING(MAX) NOT NULL,

) PRIMARY KEY (AdvertiserId, ReportConfigId),
  INTERLEAVE IN PARENT Advertisers ON DELETE CASCADE;

-- Used by Data Provider and Advertiser APIs to configure and list reports.
CREATE UNIQUE INDEX ReportConfigsByExternalId
  ON ReportConfigs(AdvertiserId, ExternalReportConfigId),
  INTERLEAVE IN Advertisers;

CREATE TABLE ReportConfigSchedules (
  AdvertiserId        INT64 NOT NULL,
  ReportConfigId      INT64 NOT NULL,
  ScheduleId          INT64 NOT NULL,

  ExternalScheduleId  INT64 NOT NULL,

  -- To support efficient queries for reports to generate.
  NextReportStartTime TIMESTAMP NOT NULL,

  -- RepetitionSpec serialized proto.
  RepetitionSpec      BYTES(MAX) NOT NULL,  -- Serialized proto
  RepetitionSpecJson  STRING(MAX) NOT NULL,
) PRIMARY KEY (AdvertiserId, ReportConfigId, ScheduleId),
  INTERLEAVE IN PARENT ReportConfigs ON DELETE CASCADE;

-- For efficiently finding ReportConfigs that are ready.
CREATE INDEX ReportConfigsByNextReportStartTime
  ON ReportConfigSchedules(NextReportStartTime, ReportConfigId);

CREATE TABLE Reports (
  AdvertiserId      INT64 NOT NULL,
  ReportConfigId    INT64 NOT NULL,
  ScheduleId        INT64 NOT NULL,
  ReportId          INT64 NOT NULL,

  ExternalReportId  INT64 NOT NULL,

  CreateTime        TIMESTAMP NOT NULL OPTIONS (allow_commit_timestamp = true),
  UpdateTime        TIMESTAMP NOT NULL OPTIONS (allow_commit_timestamp = true),

  WindowStartTime   TIMESTAMP NOT NULL,
  WindowEndTime     TIMESTAMP NOT NULL,
  State             INT64 NOT NULL,  -- Proto enum encoded as int

  -- ReportDetails serialized proto
  ReportDetails     BYTES(MAX) NOT NULL,
  ReportDetailsJson STRING(MAX) NOT NULL,
) PRIMARY KEY (AdvertiserId, ReportConfigId, ScheduleId, ReportId),
  INTERLEAVE IN PARENT ReportConfigSchedules ON DELETE CASCADE;

-- Enable idempotent Report creation from ReportConfigs.
CREATE INDEX ReportsByTimeWindow
  ON Reports(AdvertiserId, ReportConfigId, WindowStartTime, WindowEndTime),
  INTERLEAVE IN ReportConfigs;

-- Enable finding reports ready to be worked on.
CREATE INDEX ReportsByState ON Reports(State, UpdateTime ASC);

CREATE UNIQUE INDEX ReportsByExternalId
  ON Reports(ExternalReportId, CreateTime DESC);

-- Contains status updates from the Duchies and within the Kingdom for a
-- particular report. For any given report, each Duchy might send many updates
-- (one or more per stage of the MPC protocol). This is used to give a bird's
-- eye view of the state of the computations to help debug and track progress.
CREATE TABLE ReportLogEntries (
  AdvertiserId    INT64 NOT NULL,
  ReportConfigId  INT64 NOT NULL,
  ScheduleId      INT64 NOT NULL,
  ReportId        INT64 NOT NULL,
  CreateTime      TIMESTAMP NOT NULL OPTIONS (allow_commit_timestamp = true),

  -- ReportLogDetails serialized proto.
  ReportLogDetails      BYTES(MAX) NOT NULL,
  ReportLogDetailsJson  STRING(MAX) NOT NULL,
) PRIMARY KEY (AdvertiserId, ReportConfigId, ScheduleId, ReportId, CreateTime),
  INTERLEAVE IN PARENT Reports ON DELETE CASCADE;

CREATE TABLE ReportConfigCampaigns (
  AdvertiserId    INT64 NOT NULL,
  ReportConfigId  INT64 NOT NULL,
  DataProviderId  INT64 NOT NULL,
  CampaignId      INT64 NOT NULL,

  CONSTRAINT FK_Campaign
    FOREIGN KEY (DataProviderId, CampaignId)
    REFERENCES Campaigns(DataProviderId, CampaignId),
) PRIMARY KEY (AdvertiserId, ReportConfigId, DataProviderId, CampaignId),
  INTERLEAVE IN PARENT ReportConfigs ON DELETE CASCADE;

-- The Metric value is actually stored by the Duchy. The Duchy has a map from
-- the ExternalRequisitionId to the blob storage path for the metric value (i.e.
-- the bytes provided by the Data Provider).
CREATE TABLE Requisitions (
  DataProviderId              INT64 NOT NULL,
  CampaignId                  INT64 NOT NULL,
  RequisitionId               INT64 NOT NULL,

  CreateTime                  TIMESTAMP NOT NULL
                              OPTIONS (allow_commit_timestamp = true),

  ExternalRequisitionId       INT64 NOT NULL,
  CombinedPublicKeyResourceId STRING(MAX) NOT NULL,

  WindowStartTime             TIMESTAMP NOT NULL,
  WindowEndTime               TIMESTAMP NOT NULL,

  State                       INT64 NOT NULL,  -- RequisitionState proto enum

  -- When a Requisition is fulfilled, this is set to the Duchy that fulfilled
  -- the Requisition.
  DuchyId                     STRING(MAX),

  -- RequisitionDetails serialized proto
  RequisitionDetails          BYTES(MAX),
  RequisitionDetailsJson      STRING(MAX),
) PRIMARY KEY (DataProviderId, CampaignId, RequisitionId),
  INTERLEAVE IN PARENT Campaigns ON DELETE CASCADE;

CREATE UNIQUE INDEX RequisitionsByExternalId ON Requisitions(ExternalRequisitionId);

-- Index to support finding pending metrics to serve to DataProviders, as well
-- as computations to start: Reports in a waiting state with all of its metrics
-- fulfilled.
CREATE INDEX RequisitionsByState
  ON Requisitions(State, DataProviderId, CampaignId, WindowStartTime, WindowEndTime);

-- This table is an optimization to support the many-to-many relationship
-- between requisitions and reports.
--
-- This could be interleaved in either Requisitions or Reports. The joins should
-- be faster with this under Reports, because sometimes the join with
-- Requisitions can be avoided.
--
-- Because there isn't a database-layer idempotency key for requisitions, we use
-- this table to "tag" the relationship between requisitions and reports in an
-- offline process.
--
-- This can be used, for example, to find Reports with all their Requisitions
-- fulfilled:
--
--   SELECT r.ReportId
--   FROM Reports AS r
--   JOIN ReportConfigs AS rc USING (ReportConfigId)
--   JOIN ReportRequisitions AS rr USING (ReportId)
--   JOIN Requisitions AS rq USING (RequisitionId)
--   WHERE rq.state = FULFILLED
--   GROUP BY r.ReportID
--   HAVING COUNT(rr.*) = rc.NumRequisitions
--
-- Or, all Reports where some ReportRequisitions are missing:
--
--  SELECT r.ReportId
--  FROM Reports AS r
--  JOIN ReportRequisitions AS rq USING (ReportConfigId, ScheduleId, ReportId)
--  JOIN ReportConfigs AS rc USING (ReportConfigId)
--  GROUP BY r.ReportId
--  HAVING COUNT(rr.RequisitionId) = rc.NumRequisitions
CREATE TABLE ReportRequisitions (
  -- PK of Reports
  AdvertiserId    INT64 NOT NULL,
  ReportConfigId  INT64 NOT NULL,
  ScheduleId      INT64 NOT NULL,
  ReportId        INT64 NOT NULL,

  -- PK of Requisitions
  DataProviderId  INT64 NOT NULL,
  CampaignId      INT64 NOT NULL,
  RequisitionId   INT64 NOT NULL,

  CONSTRAINT FK_Requisition
    FOREIGN KEY (DataProviderId, CampaignId, RequisitionId)
    REFERENCES Requisitions(DataProviderId, CampaignId, RequisitionId),
) PRIMARY KEY (AdvertiserId, ReportConfigId, ScheduleId, ReportId,
               DataProviderId, CampaignId, RequisitionId),
  INTERLEAVE IN PARENT Reports ON DELETE CASCADE;

CREATE UNIQUE INDEX ReportRequisitionsByRequisition
  ON ReportRequisitions(
    DataProviderId, CampaignId, RequisitionId,  -- Requisitions PK
    AdvertiserId, ReportConfigId, ScheduleId, ReportId -- Reports PK
  );
