// Copyright 2020 The Cross-Media Measurement Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package wfa.measurement.protocol;

import "wfa/measurement/internal/duchy/config/protocols_setup_config.proto";
import "wfa/measurement/protocol/differential_privacy.proto";
import "wfa/measurement/protocol/el_gamal_key.proto";
import "wfa/measurement/protocol/requisition.proto";

option java_package = "org.wfanet.measurement.protocol";
option java_multiple_files = true;

// LiquidLegionsSketchAggregationV2 (3-round MPC) protocol.
message LiquidLegionsSketchAggregationV2 {
  enum Stage {
    // The computation stage is unknown. This is never set intentionally.
    STAGE_UNKNOWN = 0;

    // The worker is in the initialization phase.
    // More specifically, each worker will create a new ElGamal key pair solely
    // used in this computation, and report the public key to the Kingdom.
    INITIALIZATION_PHASE = 1;

    // The computation is initialized locally. The worker is waiting for the
    // list of local requisitions and the public ElGamal key set used in this
    // computation from the Kingdom.
    WAIT_REQUISITIONS_AND_KEY_SET = 2;

    // The worker is in the confirmation phase.
    // More specifically, the worker should confirm
    //   1. All data providers' participation_signatures are valid.
    //   2. All duchies' ElGamal public keys are valid.
    //   3. All local fulfilled requisitions are available.
    // After confirmation, the computation enters WAIT_SETUP_PHASE_INPUTS at the
    // aggregator worker and WAIT_TO_START at non-aggregator workers.
    CONFIRMATION_PHASE = 3;

    // The computation is confirmed locally, and the non-aggregator worker is
    // waiting for the signal from the kingdom to start the MPC protocol.
    WAIT_TO_START = 4;

    // The aggregator worker is waiting for other MPC workers' local combined
    // register vector (CRV) to start working on the setup phase.
    WAIT_SETUP_PHASE_INPUTS = 5;

    // The worker is in the setup phase.
    // More specifically, a non-aggregator worker will add noise to its local
    // CRV, and send the noised CRV to the aggregator. The aggregator worker
    // will add noise to its local CRV, and then combine it together with CRVs
    // received from all other non-aggregator workers and create a global CRV.
    SETUP_PHASE = 6;

    // The worker is waiting to receive a copy of global CRV from the previous
    // worker in the ring of workers to start working on the execution phase
    // one.
    WAIT_EXECUTION_PHASE_ONE_INPUTS = 7;

    // The worker is in the execution phase one.
    // More specifically, a non-aggregator worker will re-encrypt its positional
    // values and re-randomized all other field and shuffle the CRV and then
    // pass the CRV to the next worker. The aggregator worker will re-encrypt
    // the position values of the sketch and joins them based on their
    // re-encrypted positional values. Combining is via the same key aggregation
    // method to create the encrypted flag and count tuples. Then, the
    // aggregator adds noise to the flag count tuples.
    EXECUTION_PHASE_ONE = 8;

    // The worker is waiting to receive a copy of the flag and count tuples from
    // the previous worker in the ring of workers to start working on the
    // execution phase two.
    WAIT_EXECUTION_PHASE_TWO_INPUTS = 9;

    // The worker is in the execution phase two.
    // More specifically, a non-aggregator worker decrypts the flag and add
    // additional encrypted noisy (flag, count) pairs. The aggregator worker
    // decrypts the flags and filters out non-DP noises and then estimates the
    // reach, then discards the destroyed registers and creates a 2-D
    // SameKeyAggregator (SKA) matrix for the un-destroyed counters.
    EXECUTION_PHASE_TWO = 10;

    // The worker is waiting to receive a copy of the SKA matrix from the
    // previous worker in the ring of workers to start working on the execution
    // phase three.
    WAIT_EXECUTION_PHASE_THREE_INPUTS = 11;

    // The worker is in the execution phase three.
    // More specifically, a non-aggregator worker decrypts the SKA matrix, and
    // the aggregator worker decrypts the SKA matrix and computes the final
    // frequency histogram.
    EXECUTION_PHASE_THREE = 12;

    // The computation is done the worker can remove BLOBs that are no longer
    // needed.
    COMPLETE = 13;
  }

  // Computation details specific to the LiquidLegions V2 protocol.
  message ComputationDetails {
    // The duchy's role in the computation.
    org.wfa.measurement.config.LiquidLegionsV2SetupConfig.RoleInComputation
        role = 1;

    // Parameters used in this computation.
    message Parameters {
      // The maximum frequency to reveal in the histogram.
      int32 maximum_frequency = 1;
      // The decay rate of the Liquid Legions sketch.
      double decay_rate = 2;
      // The maximum size of the Liquid Legions sketch.
      int64 max_size = 3;
      // Noise parameters selected for the LiquidLegionV2 MPC protocol.
      // Only used as the configuration file consumed by the LiquidLegionV2Mill.
      message NoiseConfig {
        // DP params for the blind histogram noise register.
        // Each of these registers contains a random register id, the same
        // constant key indicating that the register is destroyed, and an
        // arbitrary count value.
        DifferentialPrivacyParams blind_histogram_noise = 1;
        // DP params for the noise for the publisher noise registers.
        // Each of these registers contains a well-known constant register id,
        // and arbitrary key and count values.
        DifferentialPrivacyParams noise_for_publisher_noise = 2;
        // DP params for the global reach DP noise registers.
        // Each of these registers contains a random register id which is out of
        // bounds of the normal id space, the same constant key indicating that
        // the register is destroyed, and an arbitrary count value.
        DifferentialPrivacyParams global_reach_dp_noise = 3;
        // Differential privacy parameters for noise tuples.
        // Same value is used for both (0, R, R) and (R, R, R) tuples.
        DifferentialPrivacyParams frequency_noise_config = 4;
      }
      // Noise parameters selected for the LiquidLegionV2 MPC protocol.
      NoiseConfig noise = 4;
    }
    Parameters parameters = 2;

    message DuchyPublicKey {
      // Name of the duchy who owns the key.
      string duchy_id = 1;
      // The ElGamal public key.
      ElGamalPublicKey public_key = 2;
    }
    // The list of duchy public keys used in this computation.
    // The list is sorted by the duchy order in the MPC ring, with the first
    // element being the first non-aggregator and the last element being the
    // aggregator.
    repeated DuchyPublicKey duchy_keys = 3;

    message ReachEstimate {
      int64 reach = 1;
    }
    // The cached reach estimation result.
    // The reach value is calculated as part of the reach estimation phase by
    // the aggregator. It is only set at the aggregator and is not shared with
    // non-aggregator nodes. The value will be included in the result for the
    // computation.
    ReachEstimate reach_estimate = 4;

    // Total number of MetricRequisitions across all duchies used in this
    // computation.
    // TODO(wangyaopw): delete after v2alpha is done
    int32 total_requisition_count = 5;
  }

  // Details about a particular attempt of running a stage of the LiquidLegionV2
  // Protocol.
  message StageDetails {
    oneof detail {
      // Details specific to the WAIT_SETUP_PHASE_INPUTS stage.
      WaitSetupPhaseInputsDetails wait_setup_phase_inputs_details = 1;
      // TODO(wangyaopw): delete after v2alpha is done.
      // Details specific to the TO_CONFIRM_REQUISITIONS stage.
      ToConfirmRequisitionsStageDetails to_confirm_requisitions_stage_details =
          2;
    }
  }

  // The WAIT_SETUP_PHASE_INPUTS stage has a bootstrapping step where it
  // requires input from all other duchies before it can move forward. The
  // bookkeeping of which duchy has provided is stored in this message.
  message WaitSetupPhaseInputsDetails {
    // A mapping of the name of a duchy to the BlobId corresponding to the
    // ComputationBlobDependency.OUTPUT BLOB where it will be written.
    //
    // Upon receiving a sketch from a duchy the OUTPUT reference with the id
    // found in this map is updated with the local copy of the blob. When all
    // the output references have a path the worker can move onto the next
    // stage.
    map<string, int64> external_duchy_local_blob_id = 1;
  }

  // TODO(wangyaopw): delete after v2alpha is done
  // The details used to run a TO_CONFIRM_REQUISITIONS stage.
  message ToConfirmRequisitionsStageDetails {
    // list of local requisitions that are required for this computation.
    repeated RequisitionKey keys = 1;
  }
}