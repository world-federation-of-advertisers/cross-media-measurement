# Copyright 2025 The Cross-Media Measurement Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# DO_NOT_SUBMIT: Remove "Test" token
name: Test Generate release notes

on:
  workflow_dispatch:
    inputs:
      milestone-name:
        type: string
        required: true
      notes-start-commitish:
        description: Full commit SHA or tag (exclusive)
        type: string
        required: true
      notes-end-commitish:
        description: Full commit SHA or tag (inclusive)
        type: string
        required: true
  workflow_call:
    inputs:
      milestone-name:
        type: string
        required: true
      notes-start-commitish:
        description: Full commit SHA or tag (exclusive)
        type: string
        required: true
      notes-end-commitish:
        description: Full commit SHA or tag (inclusive)
        type: string
        required: true  
    outputs:
      summary:
        description: "Release notes"
        value: ${{ jobs.generate-release-notes.outputs.summary }}

jobs:
  generate-release-notes:
    name: Generate relnotes
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      pull-requests: read
      issues: read
    outputs:
      summary: ${{ steps.generate-release-notes.outputs.summary }}
    steps:
      - name: Checkout (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Generate highlights section
        id: generate-highlights
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          MILESTONE: ${{ inputs.milestone-name }}
        run: |
          set -euo pipefail
          
          notes_json_array=$(gh issue list --milestone "${MILESTONE}" \
            --search 'type:"Feature request" state:closed' \
            --json number,title \
            --jq 'map("\(.title). See [Issue #\(.number)]")')

          jq . <<< "${notes_json_array}"

          printf "json=%s\n" "$(jq -c . <<< ${notes_json_array})" >> $GITHUB_OUTPUT

      - name: Validate start and end commitish
        shell: bash
        env:
          NOTES_START_COMMITISH: ${{ inputs.notes-start-commitish }}
          NOTES_END_COMMITISH: ${{ inputs.notes-end-commitish }}
        run: |
          set -euo pipefail
          git rev-parse --verify "${NOTES_START_COMMITISH}"
          git rev-parse --verify "${NOTES_END_COMMITISH}"

      - uses: actions/setup-python@v6
        with: 
          python-version: '3.13'

      - name: Fetch PRs data
        id: fetch-prs-data
        env:
          GH_TOKEN: ${{ github.token }}
          START_COMMITISH: ${{ inputs.notes-start-commitish }}
          END_COMMITISH: ${{ inputs.notes-end-commitish }}
        run: |
          python - <<'PY'
          import os
          import re
          import json
          import subprocess
          import sys

          def run_cmd(cmd, input_text=None):
              return subprocess.run(
                  cmd, check=True, text=True, stdout=subprocess.PIPE, input=input_text
              ).stdout

          def get_commits_in_range(start_exclusive, end_inclusive):
            git_log_out = run_cmd(["git", "--no-pager", "log", "--format=%s", f"{start_exclusive}..{end_inclusive}"])
            return [line for line in git_log_out.splitlines() if line]

          def fetch_issue_data(issue_number):
              out = run_cmd([
                  "gh", "api",
                  "-H", "Accept: application/vnd.github+json",
                  "-H", "X-GitHub-Api-Version: 2022-11-28",
                  f"/repos/world-federation-of-advertisers/cross-media-measurement/issues/{issue_number}",
              ])
              data = json.loads(out)
              print(f"Processing issue: {issue_number}. Got response: {data}")
              issue_type = (data.get("type") or {}).get("name", "_NO_TYPE_")
              issue_title = data.get("title")
              return issue_type, issue_title

          def get_pr_number_from(commit_title):
              match = re.search(r"\(#(\d+)\)$", commit_title)
              return int(match.group(1)) if match else None

          def fetch_pr_data(pr_number):
              response = run_cmd(["gh", "pr", "view", str(pr_number), "--json", "body,author"])
              response_json = json.loads(response)
              return response_json["body"], response_json["author"]["login"]

          def get_trailers(message):
              # A new line is added before the message. This is to ensure the trailers are parsed correctly in case the body consists only of trailers.
              trailers_text = run_cmd(["git", "interpret-trailers", "--trim-empty", "--parse"], input_text="\n" + message)
              # not a dict because there may be repeated keys
              trailers = []
              for line in trailers_text.splitlines():
                  m = re.match(r'^([^:]+):\s(.*)$', line)
                  trailers.append({"key":m.group(1), "value":m.group(2)})
              return trailers

          def compute_pr_output_from(commit_title):
              pr_number = get_pr_number_from(commit_title)
              if not pr_number:
                  print(f"No PR number: {commit_title}")
                  return {}

              pr_body, pr_author_login = fetch_pr_data(pr_number)

              trailers = get_trailers(pr_body)

              pr_output = {}
              pr_output["pr_id"] = pr_number
              pr_output["pr_title"] = commit_title
              pr_output["pr_author"] = pr_author_login

              for trailer in trailers:
                  key, value = trailer["key"], trailer["value"]
                  if key == "Issue":
                      if re.fullmatch(r"#\d+", value):
                          issue_number = int(value[1:])
                          issue_type, issue_title = fetch_issue_data(issue_number)
                          pr_output.setdefault("issues",[]).append({"id":issue_number, "type":issue_type, "title":issue_title})
                  elif key in ("RELNOTES", "BREAKING-CHANGE"):
                      pr_output.setdefault(key.lower().replace("-", "_"), []).append(value)
              return pr_output

          commits = get_commits_in_range(os.getenv("START_COMMITISH"), os.getenv("END_COMMITISH"))
          output = []
          for commit_title in commits:
              print(f"Processing: {commit_title}")
              pr_output = compute_pr_output_from(commit_title)
              if pr_output:
                output.append(pr_output)
                print(json.dumps(pr_output))

          json_output=json.dumps(output)
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              print(f"json={json_output}", file=f)
          PY

      - name: Print debug data
        env:
          JSON: ${{ steps.fetch-prs-data.outputs.json }}
        run: |
          jq . <<< "${JSON}"

      - name: Generate issues addressed section
        id: generate-issues-addressed
        env:
          JSON: ${{ steps.fetch-prs-data.outputs.json }}
        run: |
          python - <<'PY'
          import os, json

          pr_data = json.loads(os.environ["JSON"])

          # keep the order in which they were first seen.
          items = []
          seen = set()

          for pr in pr_data:
              for issue in pr.get("issues", []):
                  if issue["type"] == "Bug":
                      title = issue["title"].rstrip('.')
                      ref = issue["id"]
                      note = f"{title}. See [Issue #{ref}]"
                      if note not in seen:
                          seen.add(note)
                          items.append(note)

          json_output=json.dumps(items)
          print(json_output)
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              print(f"json={json_output}", file=f)
          PY

      - name: Generate potentially requiring action section
        id: generate-potentially-requiring-action
        env:
          JSON: ${{ steps.fetch-prs-data.outputs.json }}
        run: |
          python - <<'PY'
          import os, json

          def _compute_note_refs(pr):
              # Prefer issue ids; fall back to the PR number if no issues
              refs = [f"[Issue #{issue['id']}]" for issue in pr.get("issues", [])]
              if not refs:
                  refs = [f"[PR #{pr['pr_id']}]"]
              return " ".join(refs)

          pr_data = json.loads(os.environ["JSON"])
          items = []

          for pr in pr_data:
              note_refs = _compute_note_refs(pr)
              for line in pr.get("relnotes", []):
                  items.append(f"{line.rstrip('.')}. See {note_refs}")
              # DO_NOT_SUBMIT: remove the "breaking-change" tag used for debugging?
              for line in pr.get("breaking_change", []):
                  items.append(f"(breaking-change) {line.rstrip('.')}. See {note_refs}")
          
          json_output=json.dumps(items)
          print(json_output)
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              print(f"json={json_output}", file=f)
          PY

      - name: Get milestone url
        id: generate-milestone-url
        shell: bash
        env: 
          GH_TOKEN: ${{ github.token }}
          MILESTONE: ${{ inputs.milestone-name }}
          MILESTONE_STATE: "all"
        run: |
          url=$(gh api "/repos/world-federation-of-advertisers/cross-media-measurement/milestones?state=${MILESTONE_STATE}&per_page=100" --paginate --jq ".[] | select(.title==\"$MILESTONE\") | .html_url")
          echo "URL for milestone ${MILESTONE} is ${url}"
          echo "url=${url}" | tee -a "$GITHUB_OUTPUT"

      - name: Generate release notes
        id: generate-release-notes
        shell: bash
        env:
          HIGHLIGHTS: ${{ steps.generate-highlights.outputs.json }}
          ISSUES_ADDRESSED: ${{ steps.generate-issues-addressed.outputs.json }}
          POTENTIALLY_REQUIRING_ACTION: ${{ steps.generate-potentially-requiring-action.outputs.json }}
          MILESTONE_URL: ${{ steps.generate-milestone-url.outputs.url}}
        run: |
          print_section() {
            local title=$1
            local json_array=$2
            echo
            echo "## ${title}"
            jq -r '.[] | "* \(.)"' <<<"${json_array}"
          }

          print_summary() {
            echo "See the [corresponding milestone](${MILESTONE_URL}) for this release."
            print_section "Highlights" "${HIGHLIGHTS}"
            print_section "Issues Addressed" "${ISSUES_ADDRESSED}"
            print_section "Potentially Requiring Action" "${POTENTIALLY_REQUIRING_ACTION}"
          }

          summary="$(print_summary)"
          echo "${summary}"
          printf 'summary<<EOF\n%s\nEOF\n' "${summary}" >> $GITHUB_OUTPUT